/* autogenerated by Processing revision 1277 on 2021-12-15 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.serial.*;
import controlP5.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class WindRoseMonitor extends PApplet {




ControlP5 cp5;
DropdownList serialPorts;

Serial _stmRef;  // Create object from Serial class
final int BAUDRATE = 19200;

//Drraw Control Variables
boolean ready = false;
int panelX = 10;
int panelY = 15;

PImage bg; //Image for background

SensingData_t sensdata;
String[] portNames;

/* ================================================== */

 public void setup() 
{
  /* size commented out by preprocessor */;
  frameRate(30);
  portNames = Serial.list();
  
  cp5 = new ControlP5(this);
  serialPorts = cp5.addDropdownList("Serial Port...").setPosition(1080,10);
  for(int i = 0 ; i < portNames.length; i++) serialPorts.addItem(portNames[i], i);
  customize(serialPorts);

  bg = loadImage("bg.png"); //Getting the bg image file
  sensdata = new SensingData_t();
  println("Program started!");
}

 public void draw()
{
  if(ready){
    if(millis() - lastget > 100){ //Loop of data grabbing (10Hz)
      getData(); //Call the state machine
      lastget = millis();
    }
    if(pack_ok){
        drawBG(bg);
        drawGrid();
        drawLPPS();
      if(millis() - lastlost > 15000){ //Loop of Lost Packs Calculation (4 p/ min)
        lostrate = lostpack * 4; //Four times the loss of 15sec = loss per minute
        lostpack = 0;
        lastlost = millis();
      }
      drawNGM();
      drawLifetime();
      drawSensors();
      println("NGM: "+binary(NGM)+" ASBM: "+binary(PApplet.parseInt(ASBM))+" Light.lux="+sensdata.light.lux);
    }
  }
  else{
    drawBG(bg);
    drawGrid();
  }
}
int oft = 24;

 public void drawBG(PImage _img){
  //Drawing the background
  background(0);
  image(_img, 1280 - 460, 0);
}

 public void drawGrid(){
  pushMatrix();
    translate(panelX,panelY+22);
    int stp = 0;
    for(int i=0; i < 32; i++){
      stp = oft * i;
      strokeWeight(2);
      stroke(60);
      line(200,stp,800,stp);
      line(160,stp-oft,200,stp);
      strokeWeight(1);
      stroke(80);
      fill(30);
      rect(0,stp-oft,180,20,10,10,10,0);
      fill(200);
      textSize(12);
      text(i,5,stp-10);
    }
  popMatrix();
}

 public String MsConversion(int MS) {
  int totalSec= (MS / 1000);
  int seconds = (MS / 1000) % 60;
  int minutes = (MS / (1000*60)) % 60;
  int hours = ((MS/(1000*60*60)) % 24);                      

  return nf(hours,2)+": " +nf(minutes,2)+ ": "+ nf(seconds,2);
}

 public void drawNGM(){
  pushMatrix();
    translate(844,696);
    for(int i=0;i<4;i++){
      fill(127,250,150);
      if((NGM>>i & 0b01) == 1){
        switch(i){
          case 0: //N
            rect(29,0,24,12,5);
            break;
          case 1: //E
            rect(69,29,12,24,5);
            break;
          case 2: //S
            rect(29,69,24,12,5);
            break;
          case 3: //W
            rect(0,29,12,24,5);
            break;
          default:
            break;
        }
      }
    }
  popMatrix();
}

 public void drawLPPS(){
  fill(255, 0, 0);
  textSize(16);
  text("LPPM: "+lostrate, 1200, 780);
}

 public void drawLifetime(){
  fill(180, 180, 0);
  textSize(16);
  text("Lifetime: "+MsConversion(lifetime), 1000, 780);
}

 public void drawSensorName(String name, int pos){
  int offset = oft * pos;
  fill(127,250,150);
  textSize(16);
  text(name, 30, 13+offset);
}

 public void drawSensorData(String data, int pos){
  int offset = oft * pos;
  fill(127,250,150);
  textSize(16);
  text(data, 220, 16+offset);
}

 public void drawSensors(){
  pushMatrix();
    translate(panelX,panelY);
    for(int i=0;i<32;i++){
      if((ASBM>>i & 0x01) == 1){
        switch(i){
          case 0:
            drawSensorName(sensor_types.coord.label, i);
            drawSensorData("X: [ "+sensdata.coord.x+" ] Y: [ "+ sensdata.coord.y +" ] Z: ["+ sensdata.coord.z +"]", i);
            break;
          case 1:
            drawSensorName(sensor_types.angle.label, i);
            drawSensorData("Pitch: [ "+sensdata.angle.pitch+" ] Roll: [ "+ sensdata.angle.roll +" ] Yaw: ["+ sensdata.angle.yaw +"]", i);
          case 2:
            drawSensorName(sensor_types.accel.label, i);
            drawSensorData("X: [ "+sensdata.accel.x+" ] Y: [ "+ sensdata.accel.y +" ] Z: ["+ sensdata.accel.z +"]", i);
            break;
          case 3:
            drawSensorName(sensor_types.ang_rate.label, i);
            drawSensorData("X: [ "+sensdata.ang_rate.x+" ] Y: [ "+ sensdata.ang_rate.y +" ] Z: ["+ sensdata.ang_rate.z +"]", i);
            break;
          case 4:
            drawSensorName(sensor_types.gps_pos.label, i);
            drawSensorData("Lat: [ "+sensdata.gps_pos.lat+" ] Lon: [ "+ sensdata.gps_pos.lon +" ] Alt: ["+ sensdata.gps_pos.alt +"] Ground Speed: ["+ sensdata.gps_pos.gspeed +"]", i);
            break;
          case 5:
            drawSensorName(sensor_types.wind.label, i);
            drawSensorData("Speed: [ "+sensdata.wind.speed+" ] Direction: [ "+ sensdata.wind.dir +" ]", i);
            break;
          case 6:
            drawSensorName(sensor_types.light.label, i);
            drawSensorData("lux: [ "+sensdata.light.lux+" ] temp: [ "+sensdata.light.temp +"K ]", i);
            break;
          default:
            break;
        }
      }
    }
  popMatrix();
}
 public void customize(DropdownList ddl) {
  ddl.setWidth(180);
  ddl.setOpen(false);
  ddl.setBackgroundColor(color(190));
  ddl.setItemHeight(20);
  ddl.setBarHeight(15);
  ddl.setColorBackground(color(60));
  ddl.setColorActive(color(0,200, 200));
}

 public void controlEvent(ControlEvent theEvent){
  if (theEvent.isController()) {
    println("event from controller --> "+theEvent.getController().getValue()+" from "+theEvent.getController());
    int port = PApplet.parseInt(theEvent.getController().getValue());
    if(_stmRef != null){
      _stmRef.stop();
      _stmRef = null;
    }
    try{
      _stmRef = new Serial(this,portNames[port],BAUDRATE);
      _stmRef.buffer(64);
      delay(100);
      ready = true;
    }catch(Exception e){
      System.err.println("Error opening serial port " + portNames[port]);
      e.printStackTrace();
      ready = false;
    }
  }
}
//WindRose Sensor Classes

class Accel_t
{
  public int x;
  public int y;
  public int z;
};

class Angle_t
{
  public int pitch; //float * 100
  public int roll; //float * 100
  public int yaw; //float * 100
};

class Ang_rate_t
{
  public int x;
  public int y;
  public int z;
};

class Coord_t
{
  public int x;
  public int y;
  public int z;
};

class  Gps_pos_t
{
  public long lat;
  public long lon;
  public long alt;
  public long gspeed;
}; //Repensar a questÃ£o do mux

class Wind_t
{
  public int speed;
  public int dir;
};


class Light_t
{
  public long lux; //x1000
  public int temp;
};

/* Structure of Sensing Data (Matches the ASBM bit sequence)*/

public enum sensor_types {
    coord("Coordinates"),
    angle("Angle"),
    accel("Acceleration"),
    ang_rate("Angular Rate"),
    gps_pos("GPS Position"),
    wind("Wind"),
    light("Light");
    
    public final String label;
    
    private sensor_types(String label) {
        this.label = label;
    }
};

class SensingData_t
{
  //[Type] [atrib] [bit_pos in ASBM by sensor_types]
  public Coord_t coord = new Coord_t();//0
  public Angle_t angle = new Angle_t();//1
  public Accel_t accel = new Accel_t();//2
  public Ang_rate_t ang_rate = new Ang_rate_t();//3
  public Gps_pos_t gps_pos = new Gps_pos_t();//4
  public Wind_t wind = new Wind_t();//5
  public Light_t light = new Light_t();//6
};
//State Machine Control Variables
byte ck_a = 0;
byte ck_b = 0; //Local CHK
byte seed_a = 0;
byte seed_b = 0; //CHK seeds from Serial data
byte NGM = 0; //Neighbourhood Map
int lifetime = 0;
long ASBM = 0;
long lastget = 0;
long lastlost = 0;
int lostpack = 0;
int lostrate = 0;
boolean pack_ok = false;

 public void checksum(int dt){
  ck_a += PApplet.parseByte(dt);
  ck_b += ck_a; 
}

 public int readsum(){
  int _data = _stmRef.read();
  checksum(_data);
  return _data;
}

 public void getData()
{
  ck_a = 0;
  ck_b = 0;
  int tries = 4;
  boolean keepgoing=true;
  pack_ok = false;
  int data;
  int DT_step=0;
  byte DT_ck_a = 0;
  byte DT_ck_b = 0; //CHK result bytes from serial data

  int numc = _stmRef.available();
  if (numc >= 0){
    //for(int i=0;i<numc;i++){
    while(_stmRef.available() > 0 && keepgoing){
      //println(numc);
      data = _stmRef.read();
      switch(DT_step)  //We start from zero. Here starts the State Machine
      {
        case 0:  
          if(data==PApplet.parseChar('W'))
          { // DATA sync char 1
            DT_step++;   //Hmmm... first data packet is correct, lets jump to the next step
          }
          break; 
        case 1:  
          if(data==PApplet.parseChar('R'))  // DATA sync char 2
          {
            DT_step++;   //Oooh... second data packet is correct, lets jump to the step 2
          }
          else 
            DT_step=0;   //Nop, not this time... so restart to step zero and try again.     
          break;
        case 2:  
          if(data==PApplet.parseChar('o')){  // DATA sync char 3
            DT_step++;   //Yayyy! third data packet is correct, lets jump to the step 3
          }
          else{ 
            DT_step=0;   //Nop, so close, but not this time... so restart from step zero and try again.
          }
          break;
        case 3:  
          if(data==PApplet.parseChar('S')){  // DATA sync char 4
            DT_step++;   //YEESSSS!!! The fourth data packet is correct, jump to the step 4
          }
          else{
            DT_step=0;   //Nop, is not correct, so restart from step zero and try again.
          }
          break;
        case 4:
          ck_a = PApplet.parseByte(data);//Getting the first chk sum seed
          DT_step++;
          break;
        case 5:
          ck_b = PApplet.parseByte(data);//Getting the second chk sum seed
          DT_step++;
          break;
        case 6:
        
          checksum(data);
          NGM = PApplet.parseByte(data); //Getting the Neighborhood State Mapping
        
          lifetime = 0;
          data = readsum();
          lifetime |= (data)<<24; //Getting the Lifetime (Byte 4)
          data = readsum();
          lifetime |= (data)<<16; //Getting the Lifetime (Byte 3)
          data = readsum();
          lifetime |= (data)<<8; //Getting the Lifetime (Byte 2)
          data = readsum();
          lifetime |= (data); //Getting the Lifetime (Byte 1)
        
          ASBM = 0x00;
          data = readsum();
          ASBM |= (data)<<24; //Getting the Active Sensor Map (Byte 4)
          data = readsum();
          ASBM |= (data)<<16;  //Getting the Active Sensor Map (Byte 3)
          data = readsum();
          ASBM |= (data)<<8;  //Getting the Active Sensor Map (Byte 2)
          data = readsum();
          ASBM |= data;  //Getting the Active Sensor Map (Byte 1)

          //HERE STARTS THE DYNAMIC SENSOR GRABBING
          for(int j=0;j<32;j++){ //Looping through the 32 bits of the Active Sensor Map
            if((ASBM>>j & 0x01) == 1){ //Checking if the bit is set (active sensor)
              switch(j){ //Checking the sensor type
                case 0: //Coordinates Sensor (Coord_t)
                  //Clearing the Coord_t structure
                  sensdata.coord.x = 0;
                  sensdata.coord.y = 0;
                  sensdata.coord.z = 0;
                  //Getting the data
                  data = readsum();
                  sensdata.coord.x |= (data) << 8;
                  data = readsum();
                  sensdata.coord.x |= data;
                  data = readsum();
                  sensdata.coord.y |= (data) << 8;
                  data = readsum();
                  sensdata.coord.y |= data;
                  data = readsum();
                  sensdata.coord.z |= (data) << 8;
                  data = readsum();
                  sensdata.coord.z |= data;
                  break;
                case 1: //Angular Sensor (Angle_t)
                  //Clearing the Angle_t structure
                  sensdata.angle.pitch = 0;
                  sensdata.angle.roll = 0;
                  sensdata.angle.yaw = 0;
                  //Getting the data
                  data = readsum();
                  sensdata.angle.pitch |= (data) << 8;
                  data = readsum();
                  sensdata.angle.pitch |= data;
                  data = readsum();
                  sensdata.angle.roll |= (data) << 8;
                  data = readsum();
                  sensdata.angle.roll |= data;
                  data = readsum();
                  sensdata.angle.yaw |= (data) << 8;
                  data = readsum();
                  sensdata.angle.yaw |= data;
                  break;
                case 2: //Accelerometer Sensor (Accel_t)
                  //Clearing the Accel_t structure
                  sensdata.accel.x = 0;
                  sensdata.accel.y = 0;
                  sensdata.accel.z = 0;
                  //Getting the data
                  data = readsum();
                  sensdata.accel.x |= (data) << 8;
                  data = readsum();
                  sensdata.accel.x |= data;
                  data = readsum();
                  sensdata.accel.y |= (data) << 8;
                  data = readsum();
                  sensdata.accel.y |= data;
                  data = readsum();
                  sensdata.accel.z |= (data) << 8;
                  data = readsum();
                  sensdata.accel.z |= data;
                  break;
                case 3: //Angular Rate Sensor (Ang_rate_t)
                  //Clearing the Ang_rate_t structure
                  sensdata.ang_rate.x = 0;
                  sensdata.ang_rate.y = 0;
                  sensdata.ang_rate.z = 0;
                  //Getting the data
                  data = readsum();
                  sensdata.ang_rate.x |= (data) << 8;
                  data = readsum();
                  sensdata.ang_rate.x |= data;
                  data = readsum();
                  sensdata.ang_rate.y |= (data) << 8;
                  data = readsum();
                  sensdata.ang_rate.y |= data;
                  data = readsum();
                  sensdata.ang_rate.z |= (data) << 8;
                  data = readsum();
                  sensdata.ang_rate.z |= data;
                  break;
                case 4: //Gps Position Sensor (Gps_pos_t)
                  //Clearing the Gps_pos_t structure
                  sensdata.gps_pos.lat = 0;
                  sensdata.gps_pos.lon = 0;
                  sensdata.gps_pos.alt = 0;
                  sensdata.gps_pos.gspeed = 0;
                  //Getting the data
                  data = readsum();
                  sensdata.gps_pos.lat |= (data) << 24;
                  data = readsum();
                  sensdata.gps_pos.lat |= (data) << 16;
                  data = readsum();
                  sensdata.gps_pos.lat |= (data) << 8;
                  data = readsum();
                  sensdata.gps_pos.lat |= data;
                  data = readsum();
                  sensdata.gps_pos.lon |= (data) << 24;
                  data = readsum();
                  sensdata.gps_pos.lon |= (data) << 16;
                  data = readsum();
                  sensdata.gps_pos.lon |= (data) << 8;
                  data = readsum();
                  sensdata.gps_pos.lon |= data;
                  data = readsum();
                  sensdata.gps_pos.alt |= (data) << 24;
                  data = readsum();
                  sensdata.gps_pos.alt |= (data) << 16;
                  data = readsum();
                  sensdata.gps_pos.alt |= (data) << 8;
                  data = readsum();
                  sensdata.gps_pos.alt |= data;
                  data = readsum();
                  sensdata.gps_pos.gspeed |= (data) << 24;
                  data = readsum();
                  sensdata.gps_pos.gspeed |= (data) << 16;
                  data = readsum();
                  sensdata.gps_pos.gspeed |= (data) << 8;
                  data = readsum();
                  sensdata.gps_pos.gspeed |= data;
                  break;
                case 5: //Wind Sensor (Wind_t)
                  //Clearing the Wind_t structure
                  sensdata.wind.speed = 0;
                  sensdata.wind.dir = 0;
                  //Getting the data
                  data = readsum();
                  sensdata.wind.speed |= (data) << 8;
                  data = readsum();
                  sensdata.wind.speed |= data;
                  data = readsum();
                  sensdata.wind.dir |= (data) << 8;
                  data = readsum();
                  sensdata.wind.dir |= data;
                  break;
                case 6: //Light Sensor (Light_t)
                  //Clearing the Light_t struct
                  sensdata.light.lux = 0;
                  sensdata.light.temp = 0;
                  //Getting the data
                  data = readsum();
                  sensdata.light.lux |= (data) << 24;
                  data = readsum();
                  sensdata.light.lux |= (data) << 16;
                  data = readsum();
                  sensdata.light.lux |= (data) << 8;
                  data = readsum();
                  sensdata.light.lux |= data;
                  data = readsum();
                  sensdata.light.temp |= (data) << 8;
                  data = readsum();
                  sensdata.light.temp |= data;
                  break;
                default:
                  break;
              }
            }
          }
          //HERE ENDS THE DYNAMIC SENSOR GRABBING
          DT_step++;
          break;
        //Checksum Block
        case 7:
          DT_ck_a = PApplet.parseByte(data); //Getting byte checksum A
          DT_step++;
          break;
        case 8:
          DT_ck_b = PApplet.parseByte(data); //Getting byte checksum B
          //println("Dat."+hex(DT_ck_a)+":"+hex(DT_ck_b));
          //println("Res."+hex(ck_a)+":"+hex(ck_b));
          
          if((ck_a==DT_ck_a) && (ck_b==DT_ck_b)){ //Chacksum is correct
            //nb->sensors = sensdata;
            pack_ok = true;
            keepgoing = false;
            //_mux.set(-1); //Inhibits the multiplexing
          }
          else{ //Checksum is not correct
            if(tries-- == 0) keepgoing = false;
            pack_ok = false;
            lostpack++;
            DT_step=0;
            ck_a = 0;
            ck_b = 0;
          }
          DT_step++;
          break;
        default:
          break;
      }
    }
    while (_stmRef.available() > 0) _stmRef.read(); //Clearing the Serial buffer
  }
}


  public void settings() { size(1280, 800); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "WindRoseMonitor" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
